
# Endatabas is a SQL document database with full history.
# This demo will demonstrate what that means.

# First, we'll pull the latest release.
docker pull docker.io/endatabas/endb:latest

# Then we'll start an empty database.
docker run --rm -p 3803:3803 -v demo_data:/app/demo_data docker.io/endatabas/endb:latest

# Clients talk to Endb over HTTP, and any HTTP client will work.
# Hello World!
curl -d "SELECT 'Hello World'" -H "Content-Type: application/sql" -X POST http://localhost:3803/sql

# Since endb schemas are per-document, there's no meaning to CREATE TABLE
# and you start right away by inserting data.
# (As a side-note, this allows you to add semi-structured data instantly
# ...for example, you could scrape a bunch of pricing data and jam it straight into endb.)
curl -d "INSERT INTO sales (name, at) VALUES ('Taro', DATE '2023-08-30')" -H "Content-Type: application/sql" -X POST http://localhost:3803/sql

# Here's the data we just inserted, returned as JSON-LD.
curl -d "SELECT * FROM sales" -H "Content-Type: application/sql" -H "Accept: application/ld+json" -X POST http://localhost:3803/sql

# Here's a more interesting query: we'll use a json content type,
# insert a jagged doc (with different columns than before) with a JSON-LD parameter
curl -d '{"q": "INSERT INTO sales {name: ?, at: ?}", "p": ["Mangoes", {"@type": "xsd:date", "@value": "2023-09-05"}]}' -H "Content-Type: application/json" -X POST http://localhost:3803/sql

# let's get our sales back out as vanilla JSON
curl -d "SELECT * FROM sales" -H "Content-Type: application/sql" -X POST http://localhost:3803/sql

# the HTTP API supports a variety of other ways to express a query,
# but they're all equivalent.

clear

# examples
ls -l examples
cd examples
less endb.py
python3
import endb
endb.Endb().sql("INSERT INTO products {name: 'Ketchup', price: 2.99}")
wc -l endb.py
wc -l endb.mjs
# we will provide idiomatic native client libraries for popular languages
# in the future -- but for now, almost anyone can write a client library
# in a few dozen lines of code

# console
less endb_console.py
# this little toy console is what we'll use for the remaining examples,
# just so we can focus on the SQL dialect. the console itself isn't
# interesting or important.
wc -l endb_console.py
./endb_console.py

# sql literals
INSERT INTO sales {name: "Ketchup", at: 2023-09-07T07:34:02}
# endb also has convenient ISO literals for dates, times, and intervals
# as well as all the SQL literals you'd expect

# joins
# briefly, it's worth noting that all joins in endb are ad-hoc
SELECT * FROM sales s JOIN products p ON s.name = p.name

# TODO: aggregate

clear

# full history
# when we say "full history", we really mean (to programmers, at least)
# that data in endb is immutable. let's see how that works.
INSERT INTO products {name: "Mustard", price: 5.99}
SELECT strftime('%Y-%m-%dT%H:%M:%S', CURRENT_TIMESTAMP) AS now;
UPDATE products SET price = 4.99 WHERE name = 'Mustard'
SELECT * FROM products WHERE name = 'Mustard'
# all queries default to running "as of now", which is the normal
# behaviour you'd expect in any other database. we see the new 4.99 price.

# SELECT * FROM products FOR SYSTEM_TIME AS OF

SELECT * FROM products FOR SYSTEM_TIME ALL WHERE name = 'Mustard'

# of course, a modern database needs to comply with laws like GDPR,
# which is why endb supports ERASE
ERASE FROM products WHERE name = 'Mustard'
SELECT * FROM products FOR SYSTEM_TIME ALL

clear

# nested
# naturally, document-shaped rows support native nested data
# while this is similar to JSON, everything in endb is strongly-typed
INSERT INTO stores {brand: "Schonfinkel's", addresses: [{city: "Ekaterinoslav", country: "Russia", active: 1888-09-29}, {city: "Gottingen", country: "Germany", active: 1920-12-20}]}
INSERT INTO stores {brand: "Curry's", addresses: [{city: "Millis", country: "USA", active: 1900-09-12}, {city: "Boston", country: "Germany", active: 1930-07-15}]}
SELECT addresses[0].city FROM stores
SELECT addresses..country FROM stores
# row literals, wildcards, and path functions also work

# TODO: nested - shorthand construct JSON

# UPDATE $path
# while many people will prefer endb's path functions for manipulating data,
# the 'update' statement also allows path expressions

UPDATE stores SET $.addresses[1].city = 'Gottingen' WHERE brand = "Curry's";
SELECT * FROM stores WHERE brand = "Curry's";

clear

# info schema
# even without forcing strict schema on tables, it is possible to inspect
# the information schema through regular queries
SELECT * FROM information_schema.columns WHERE table_name = 'stores';

cd ~/tmp/endb/
