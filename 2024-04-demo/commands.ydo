
@CTRL+PGDN

@RETURN

@CTRL+L

# Endatabas is a SQL document database with full history.
# This demo will explain what that means.

# Let's pull the latest release.
docker pull docker.io/endatabas/endb:latest

# ...and start an empty database.
docker run --rm -p 3803:3803 -v demo_data:/app/demo_data docker.io/endatabas/endb:latest

@CTRL+PGDN

##############################################
# We'll use the Python client for this demo. #
##############################################

# pip install endb
pip install endb

# and start the endb console
endb_console

#############################################
# Endb is schemaless, but fully relational. #
#############################################

# This means you start right away by inserting a row with SQL you already know.
# No need for CREATE TABLE.

INSERT INTO sales (name, price, at) VALUES ('Taro', 1.99, DATE '2023-08-30');

@RETURN

# Endb also lets you insert documents directly.

INSERT INTO products {name: 'Mangoes', price: 2.99};

# (This allows you to jam semi-structured data,
#  like random json documents, straight into endb.)

@RETURN

# Here is the sales data we just inserted.

SELECT * FROM sales;

@RETURN

# Let's insert some jagged data, with different columns than before.
# Even though Endb is schemaless, it is also strongly typed.
# It supports JSON but isn't limited to JSON.

INSERT INTO sales {name: "Mangoes", price: 15.99, at: 2023-09-05, note: "Alphonso"};

@RETURN

# For example, timestamp literals can use either SQL or ISO formats.
# You'll also note the TEXT literal permits double quotes.

INSERT INTO sales {name: "Mangoes", price: 22.99, at: 2023-09-07T07:34:02};

# Endb also has ISO literals for dates, times, intervals
# and all the standard SQL literals you'd expect.

@RETURN

# All joins in endb are ad-hoc.
# Exploratory queries give users a lot of the power of a graph database.

SELECT * FROM sales s JOIN products p ON s.name = p.name;

@RETURN

# Here's a simple aggregate.

SELECT p.name, SUM(s.price) AS total
  FROM sales s
  JOIN products p
  ON s.name = p.name
  GROUP BY p.name;

# Endb stores all data as Apache Arrow.
# Analytics over columnar storage can be very fast.

@RETURN

################################
# Let's look at "full history" #
################################

@CTRL+L

# When we say "full history", we mean that data in endb is immutable.

INSERT INTO products {name: "Mustard", price: 5.99};

@RETURN

# We'll grab the current time before we update, so we can time-travel back here later.

SELECT strftime('%Y-%m-%dT%H:%M:%S', CURRENT_TIMESTAMP) AS now;

@RETURN

UPDATE products SET price = 4.99 WHERE name = 'Mustard';

@RETURN

# All queries default to running "as of now", which is the normal
# behaviour you'd expect in a regular, mutable database.
# We see the new 4.99 price.

SELECT * FROM products WHERE name = 'Mustard';

@RETURN

# However, we can travel back in time to the timestamp between
# our insert and update to see the old 5.99 value.

@AS_OF

@RETURN

# It's possible to see across all of system time.
# Here are all the past states for Mustard:

SELECT * FROM products FOR SYSTEM_TIME ALL WHERE name = 'Mustard';

@RETURN

# DELETE works the same way as UPDATE.
# Instead of destroying data, it behaves like a safe soft-delete.
#
# Of course, any modern database needs to comply with laws like GDPR,
# so endb supports an ERASE statement.

ERASE FROM products WHERE name = 'Mustard';

@RETURN

# Mustard is gone.
SELECT * FROM products FOR SYSTEM_TIME ALL;


###############################
# Now let's look at Documents #
###############################

@CTRL+L

# Document-shaped rows support strongly-typed, native nested data.

# we'll add a couple stores

INSERT INTO stores {brand: "Schonfinkel's", addresses: [{city: "Odessa", country: "Ukraine", active: 1906-09-01}, {city: "Gottingen", country: "Germany", active: 1920-12-20}]};
INSERT INTO stores {brand: "Curry's", addresses: [{city: "Millis", country: "USA", active: 1900-09-12}, {city: "Boston", country: "Germany", active: 1930-07-15}]};
INSERT INTO stores {brand: "Church's", addresses: [{city: "New Jersey", country: "United States of America", active: 1929-09-01}, {city: "Gottingen", country: "Germany", active: 1928-09-01}]};

@RETURN

# ...select from a nested column

SELECT addresses[0].city FROM stores;

@RETURN

# ...and try recursion

SELECT addresses..country FROM stores;

# Endb's documents also support row literals, wildcards, spreads,
# shorthand fields, computed fields, and path functions.

@RETURN

# In addition to path *functions*,
# the 'update' statement also allows path *expressions*.

UPDATE stores SET $.addresses[1].city = 'Gottingen' WHERE brand = "Curry's";

@RETURN

SELECT * FROM stores WHERE brand = "Curry's";

# Here, we've changed the nested city field for "Curry's".


############################################
# Endb is open source and standards-based. #
############################################

# It speaks HTTP and WebSockets, so even without a console or client,
# it's possible to send queries over simple tools like curl and websocat.

curl -d "SELECT * FROM sales;" -H "Content-Type: application/sql" -X POST http://localhost:3803/sql

# Endb SQL is more standards-compliant than MySQL, SQL Server, and Oracle.

@RETURN

# You can try Endb directly in a browser with our Wasm Demo at:
# endatabas.com/demo

echo "https://www.endatabas.com/demo"

# done! reset
cd ~/tmp/endb/
